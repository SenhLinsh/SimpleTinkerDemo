//apply tinker插件
apply plugin: 'com.tencent.tinker.patch'

// 每次打包补丁时需要配置的变量
def baseInfo = "app-1.0.0-0516-20-40-02"

def isDebug = false;

def tinkerEnabled = true

// 下面不需要每次重新配置
def variantName = isDebug ? "debug" : "release";

def bakPath = isDebug ? file("${buildDir}/bakApk/") : file("bakApk/");

def tinkerPathPrefix = "${bakPath}/${baseInfo}/${variantName}";

def tinkerOldApkPath = "${tinkerPathPrefix}/${project.name}-${variantName}.apk" // 旧APK地址

def tinkerApplyMappingPath = "${tinkerPathPrefix}/${project.name}-${variantName}-mapping.txt" // 旧Mapping文件地址

def tinkerApplyResourcePath = "${tinkerPathPrefix}/${project.name}-${variantName}-R.txt" // 旧R文件地址

def date = new Date().format("MMdd-HH-mm-ss")

tinkerPatch {

    oldApk = tinkerOldApkPath

    ignoreWarning = false

    useSign = true

    tinkerEnable = tinkerEnabled

    buildConfig {

        applyMapping = tinkerApplyMappingPath

        applyResourceMapping = tinkerApplyResourcePath

        tinkerId = android.defaultConfig.versionName;

        keepDexApply = false

        /**
         * 是否使用加固模式，仅仅将变更的类合成补丁。注意，这种模式仅仅可以用于加固应用中。
         * 如果设置为 true, 生成的补丁包将包含所有的变更类而不是变更文件
         */
        isProtectedApp = false
    }

    dex {

        dexMode = "jar"

        pattern = ["classes*.dex",
                   "assets/secondary-dex-?.jar"]

        /**
         * 它定义了哪些类在加载补丁包的时候会用到, 这些类是通过Tinker无法修改的类，也是一定要放在main dex的类。
         * Tinker 已经自动把需要的类配置好了, 这个一般不需要配置.
         */
        loader = [
                // 如果有不希望被 Tinker 更改的类, 可放到其中
                // 如 "tinker.sample.android.app.BaseBuildInfo"
        ]
    }

    lib {
        pattern = ["lib/*/*.so"]
    }

    res {
        pattern = ["res/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]

        ignoreChange = ["assets/sample_meta.txt"]

        largeModSize = 100
    }

    /**
     * 用于生成补丁包中的 'package_meta.txt' 文件
     * 可选, 默认生成 "TINKER_ID" 和 "NEW_TINKER_ID"
     */
    packageConfig {
        /**
         * 运行时可以通过 TinkerLoadResult.getPackageConfigByName() 得到相应的数值, 但是建议直接通过修改代码来实现，例如BuildConfig
         * platform 只是一个示范, 你可以使用 sdkVersion / brand 等在 TinkerPatchListener 内解析使用, 这样就可以有条件地加载补丁了
         */
        configField("platform", "all")
    }

    sevenZip {
        zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
    }
}

/**
 * 将 APK、Mapping 文件、R 文件复制到指定目录
 */
android.applicationVariants.all { variant ->

    def taskName = variant.name

    tasks.all {
        if ("assemble${taskName.capitalize()}".equalsIgnoreCase(it.name)) {

            it.doLast {
                copy {
                    def release = isDebug ? "" : "-${versionName}";
                    def pathPrefix = "${bakPath}/${project.name}${release}-${date}/${variantName}/"
                    def name = "${project.name}-${variantName}"

                    // 复制APK文件
                    def destPath = file(pathPrefix)
                    from variant.outputs.outputFile
                    into destPath
                    rename { String fileName ->
                        fileName.replaceFirst(".+\\.apk", "${name}.apk");
                    }

                    // 复制mapping文件
                    from "${buildDir}/outputs/mapping/${variant.dirName}/mapping.txt"
                    into destPath
                    rename { String fileName ->
                        fileName.replace("mapping.txt", "${name}-mapping.txt")
                    }

                    // 复制R文件
                    from "${buildDir}/intermediates/symbols/${variant.dirName}/R.txt"
                    into destPath
                    rename { String fileName ->
                        fileName.replace("R.txt", "${name}-R.txt")
                    }
                }
            }
        }
    }
}